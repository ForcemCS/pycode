## 概念
### 共享对象

当一个对象（如整数、字符串、元组）是不可变的，Python 会直接共享同一个对象的引用，而不会创建新的对象。

```python
a = 30
b = a  # 直接共享同一个整数对象

print(a is b)  # True

```

### 复制引用

当一个对象是**可变的**（比如列表、字典），如果你只是**赋值**（而不是创建新对象），Python **不会复制数据**，而是让新变量**指向同一个对象**。

```python
lst1 = [1, 2, 3]
lst2 = lst1  # 赋值，但不会创建新的列表

lst2.append(4)  # 修改 lst2

print(lst1)  # [1, 2, 3, 4] -> lst1 也变了
print(lst1 is lst2)  # True
```

### 复制对象（深拷贝 vs. 浅拷贝）

都是创建新的对象，但是有本质区别

+ 浅拷贝(改变相同的部分，会把原来的改掉)

  ```python
  m1 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
  m2 = m1.copy()
  
  m2.append([10, 20, 30])
  print(m1)
  print(m2)
  print(m1[0] is m2[0])
  print("------------")
  m2[0].append(-1)
  print(m1)
  print(m2)
  ```

  结果如下

  ```python
  [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
  [[1, 0, 0], [0, 1, 0], [0, 0, 1], [10, 20, 30]]
  True
  ------------
  [[1, 0, 0, -1], [0, 1, 0], [0, 0, 1]]
  [[1, 0, 0, -1], [0, 1, 0], [0, 0, 1], [10, 20, 30]]
  ```

+ 深拷贝

  ```
  from  copy import deepcopy
  m1 = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
  m2 = deepcopy(m1)
  m2[0].append(-1)
  print(m1[0],m2[0])
  ```

  结果如下

  ```python
  [1, 0, 0] [1, 0, 0, -1]
  ```

### 切片

会创建新的对象

+ 示例1

  ```python
  l = [ [0, 0, 0, 0], [1, 1, 1], [2, 2, 2]]
  
  
  sub = l[0:2]
  print(sub is l) ##false
  print(sub)
  sub[0] = "Python"
  print(sub)
  print(l)
  ```

  结果如下

  ```
  False
  [[0, 0, 0, 0], [1, 1, 1]]
  ['Python', [1, 1, 1]]
  [[0, 0, 0, 0], [1, 1, 1], [2, 2, 2]]
  ```

+ 示例二

  ```python
  s = "hello world"
  
  ##当间隔为负数的时候，start省略，表示从-1开始，end省略，默认值是0
  print(s[::-1])
  print(s[1:6:1])
  print(s[1:6])
  
  print(s[:-4:-1])
  print(s[2::-1])
  print(repr(s[:4:-1]))
  
  ## 判断是不是关于e对称
  a = "racecar"
  print(a == a[::-1])
  ```

  结果如下：

  ```
  dlrow olleh
  ello 
  ello 
  dlr
  leh
  'dlrow '
  True
  ```

+ 替换原list中指定范围的元素,可以时多对多

  ```python
  l = [1, 20, 30, 5, 6]
  
  l[1:3] = (2, 3, 4)  # 使用切片赋值
  
  print(l)  
  
  ```

  ```python
  l = [10, 40]
  l[1:1] = [20, 30]  # 在索引1的位置插入 [20, 30]
  print(l)  # [10, 20, 30, 40]
  ```

  

