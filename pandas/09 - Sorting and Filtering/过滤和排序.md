### 基础排序

1. **`df.sort_index()`**: **按行索引（index）排序**。

   - 如果你的行索引是数字（比如 0, 1, 2, 3...），这个函数会按数字大小排序。
   - 如果你的行索引是字母（比如 'a', 'b', 'c'...），它会按字母顺序排序。
   - 默认是升序（`ascending=True`），小的在前。

2. **`df.sort_values('col label')`**: **按某一列（column）的值排序**。

   - 这是最常用的排序方式。你指定一个列名，Pandas 就会根据这一列里的值来对整个 DataFrame 的行进行重新排序。
   - 同样，默认是升序。

   ```python
   import pandas as pd
   import numpy as np
   
   # 创建一个 DataFrame
   df = pd.DataFrame({
       'city': ['Shanghai', 'Rome', 'Beijing', 'NYC'],
       'sales': [300, 150, 250, 400]
   })
   
   print("原始 DataFrame:")
   print(df)
   print("-" * 20)
   
   # 1. 基础排序 (按字母顺序)
   sorted_alphabetically = df.sort_values('city')
   print("按字母顺序排序:")
   print(sorted_alphabetically)
   print("-" * 20)
   ```

### Python 的 `sorted(key=...)`

列表 `l = ['Z', 'a', 'b']`。

如果直接 `sorted(l)`，结果会是 `['Z', 'a', 'b']`。因为在计算机的编码（如ASCII）中，大写字母 'Z' 的值是小于小写字母 'a' 的。但这通常不是我们想要的 "按字母顺序" 排列。我们希望忽略大小写。

`sorted(l, key=lambda x: x.casefold())`

- 工作原理
  1. `sorted` 函数在比较元素之前，会先把 `key` 指定的函数（这里是 `lambda x: x.casefold()`）应用到**每一个元素**上。`casefold()` 是一个比 `lower()` 更强的转小写方法。
  2. 对于 `'Z'`，`key`函数把它转换成 `'z'`。
  3. 对于 `'a'`，`key`函数把它转换成 `'a'`。
  4. 对于 `'b'`，`key`函数把它转换成 `'b'`。
  5. 现在，`sorted` 不再直接比较 `'Z', 'a', 'b'`，而是比较它们经过 `key` 函数处理后得到的**临时键（sort keys）**：`'z', 'a', 'b'`。
  6. 根据这些临时键排序，顺序是 `'a', 'b', 'z'`。
  7. 最后，`sorted` 函数返回**原始列表**中对应这个新顺序的元素。所以结果是 `['a', 'b', 'Z']`。

**核心思想**: `key` 函数对每个元素进行**预处理**，生成一个用于排序的"代理"值，实际排序是根据这些代理值进行的。这个函数是**逐个元素（one by one）**应用的。

### Pandas DataFrame 中的 `key` 参数

- **核心区别**: 在 Pandas 中，`key` 函数**不是**作用于单个值（one by one），而是作用于**整个series对象**。这种操作叫做**向量化 (vectorized)**。
- **规则**:
  1. 你提供给 `key` 的函数，其输入参数将是**整个要排序series**
  2. 这个函数必须返回一个**新的 Series 或类似数组的结构**，其长度必须和输入的 Series 完全一样。
  3. Pandas 会使用你函数返回的这个新 Series 作为排序的依据。

```
# 现在，我们想按城市名的长度来排序。这就需要用到 key 参数。
import pandas as pd
import numpy as np

# 创建一个 DataFrame
df = pd.DataFrame({
    'city': ['Shanghai', 'Rome', 'Beijing', 'NYC'],
    'sales': [300, 150, 250, 400]
})


# 原始 DataFrame:
#        city  sales
# 0  Shanghai    300
# 1      Rome    150
# 2   Beijing    250
# 3       NYC    400

key_function = lambda s: s.str.len()

sorted_by_length = df.sort_values('city', key=key_function)
print("按城市名长度排序:")
print(sorted_by_length)
```

**发生了什么？**

1. 我们调用 `df.sort_values('city', key=...)`。
2. Pandas 取出 `'city'` 这一列，它是一个 Series: `s = pd.Series(['Shanghai', 'Rome', 'Beijing', 'NYC'])`。
3. Pandas 将**整个 `s`** 传递给我们的 `key_function`。
4. `key_function` 内部执行 `s.str.len()`。这是一个向量化操作，它对 `s` 中的每个元素计算长度，并返回一个**新的 Series**：`pd.Series([8, 4, 7, 3])`。
5. 现在，Pandas 使用这个新生成的长度 Series `[8, 4, 7, 3]` 作为排序的依据。
6. `[8, 4, 7, 3]` 排序后的顺序是 `3, 4, 7, 8`，对应的原始索引是 `3, 1, 2, 0`。
7. `sort_values` 根据这个新的索引顺序 `[3, 1, 2, 0]` 来排列原始 DataFrame 的行。

最终输出：

```python
按城市名长度排序:
       city  sales
3       NYC    400  # 长度 3
1      Rome    150  # 长度 4
2   Beijing    250  # 长度 7
0  Shanghai    300  # 长度 8
```

